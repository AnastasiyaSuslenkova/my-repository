# -*- coding: utf-8 -*-
"""task_5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MWpgTSc-jKsg5ybmxAmLsf-1xNnYdHOl

Обновила снова
"""

import random
import copy
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

class ClassifiedKmeansData:

  def __init__ (self, k, df):
    self.k = k
    self.df = df

  def random_centers(self):
    centers = np.zeros((self.k, 2))
    for j in range(self.k):
      i = np.random.choice(range(n), replace=False)
      centers[j] = self.df.to_numpy()[i]
    return centers

  def data_distribution(self, centers):
    labels = np.zeros(len(self.df))
    for i in range(len(self.df)):
      min_distance = float('inf')
      distance = np.sqrt(np.sum(np.square(self.df.iloc[i].to_numpy() - centers), axis=1))
      labels[i] = np.argmin(distance)
    return labels

  def centers_update_and_graph(self, labels):
    centers = np.zeros((self.k, 2))
    fig = plt.figure()
    centers_x = []
    centers_y = []
    for i in range(self.k):
      arrx = []
      arry = []
      for j in range(len(self.df)):
        if labels[j] == i:
          arrx.append(self.df.iloc[j]['x'])
          arry.append(self.df.iloc[j]['y'])
      centers[i] = [np.mean(arrx), np.mean(arry)]
      plt.scatter(arrx, arry)
      centers_x.append(centers[i][0])
      centers_y.append(centers[i][1])
    plt.scatter(centers_x, centers_y)
    plt.show()
    return centers

  def predict (self):
    prev_centers = self.random_centers()
    labels = self.data_distribution(prev_centers)
    while True:
     centers = self.centers_update_and_graph(labels)
     labels = self.data_distribution(centers)
     if np.array_equal(prev_centers, centers):
       self.labels = labels
       break
     prev_centers = centers

#сгенерить данные
dim = 2
k = 4
max_value = 2
n = 100 
E = (1,2)
df = pd.DataFrame({'x': [random.normalvariate(random.choice(E), 0.25) for i in range(n)], 'y': [random.normalvariate(random.choice(E), 0.25) for i in range(n)]})

df_kmeans = ClassifiedKmeansData(k, df)
df_kmeans.predict()

"""Much better, but:

1. `centers[j] = random.choice(self.df.to_numpy())`

    This line can potentially choose the same point twice. The centroids are supposed to be distinct. Use `numpy.random.choice`, it has a parameter that safeguards against that.

2. `np.array_equal(prev_centers, centers)`

    Machine floating-point numbers are unlikely to be equal, it should be enough that they are "close", meaning the difference is less than some small epsilon. Use `numpy.isclose`.

3. `prev_centers = copy.deepcopy(centers)`

   I'm not sure why you need to make a deepcopy, but I suspect this may stem from a misunderstanding of how identifiers work in Python.

   In an expression `identifier = value` (note: not += or -= or anything, just = ) regardless of the properties of the data type of the value that identifier refers to before the assignment, the result is always the same. A completely new address is assigned to the identifier. The object it used to refer to is not changed.

   So at line `centers = self.centers_update_and_graph(labels)`, a completely new object is assigned to `centers`, so if you simply assign `centers` to `prev_centers` without any deepcopying, nothing will happen to *that* object later on.

Thank you!
1. Done.
2. I've used numpy.allclose(), because in this case isclose would return an array as I understand.
3. Thank you, I understood.
"""